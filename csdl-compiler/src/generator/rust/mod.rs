// SPDX-FileCopyrightText: Copyright (c) 2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Rust code generator for compiled structures.
//!
//! Following rules are applied for generation.
//!
//! Namespaces:
//!  - Each namespace is generated in each own module
//!  - Camel case identifieds in namespaces are converted to snake case.
//!  - If namespace more than one ids then submodules are generated in according to namespace.
//!

/// Mod definition.
pub mod mod_def;

/// Struct definition.
pub mod struct_def;

/// Documentation generation.
pub mod doc;

use crate::compiler::QualifiedName;
use crate::edmx::attribute_values::SimpleIdentifier;
use crate::generator::CodeGenerator;
use crate::generator::Compiled;
use crate::generator::Error as GenError;
use proc_macro2::TokenStream;
use quote::quote;
use std::fmt::Display;
use std::fmt::Formatter;
use std::fmt::Result as FmtResult;

/// Reexport of `ModName`.
pub type ModName<'a> = mod_def::name::ModName<'a>;

/// Reexport of `ModDef`.
pub type ModDef<'a> = mod_def::ModDef<'a>;

/// Reexport of `StructName`.
pub type StructName<'a> = struct_def::name::StructName<'a>;

/// Reexport of `StructDef`.
pub type StructDef<'a> = struct_def::StructDef<'a>;

/// Errors that can occur during code generation.
pub enum Error<'a> {
    NameConflict(QualifiedName<'a>),
    CreateStruct(&'a SimpleIdentifier, Box<Error<'a>>),
}

impl<'a> GenError<'a> for Error<'a> {}

impl Display for Error<'_> {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        match self {
            Self::NameConflict(name) => write!(f, "name conflict for {name}"),
            Self::CreateStruct(id, err) => write!(f, "while create struct {id}\n{err}"),
        }
    }
}

#[derive(Debug)]
pub struct RustGenerator<'a> {
    root: ModDef<'a>,
}

fn convert_err<'a>(e: Error<'a>) -> Box<dyn GenError<'a> + 'a> {
    Box::new(e)
}

impl<'a> CodeGenerator<'a> for RustGenerator<'a> {
    fn new(compiled: Compiled<'a>) -> Result<Self, Box<dyn GenError<'a> + 'a>> {
        let root = compiled
            .complex_types
            .into_iter()
            .try_fold(ModDef::default(), |m, (_, ct)| m.add_complex_type(ct))
            .map_err(convert_err)?;
        let root = compiled
            .entity_types
            .into_iter()
            .try_fold(root, |m, (_, et)| m.add_entity_type(et))
            .map_err(convert_err)?;
        Ok(Self { root })
    }
}

impl RustGenerator<'_> {
    #[must_use]
    pub fn generate(self) -> TokenStream {
        let mut tokens = TokenStream::new();
        tokens.extend(quote! {
            //! This code is automatically generated by CSDL
            //! generator. DO NOT EDIT!
            //!
        });
        self.root.generate(&mut tokens);
        tokens
    }
}
