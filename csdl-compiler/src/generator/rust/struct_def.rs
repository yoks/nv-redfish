// SPDX-FileCopyrightText: Copyright (c) 2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::compiler::Action;
use crate::compiler::ActionsMap;
use crate::compiler::NavProperty;
use crate::compiler::OData;
use crate::compiler::Parameter;
use crate::compiler::ParameterType;
use crate::compiler::Properties;
use crate::compiler::Property;
use crate::compiler::PropertyType;
use crate::compiler::QualifiedName;
use crate::generator::rust::ActionName;
use crate::generator::rust::Config;
use crate::generator::rust::Error;
use crate::generator::rust::FullTypeName;
use crate::generator::rust::StructFieldName;
use crate::generator::rust::TypeName;
use crate::generator::rust::doc::format_and_generate as doc_format_and_generate;
use crate::odata::annotations::Permissions;
use proc_macro2::Delimiter;
use proc_macro2::Group;
use proc_macro2::Ident;
use proc_macro2::Literal;
use proc_macro2::Span;
use proc_macro2::TokenStream;
use proc_macro2::TokenTree;
use quote::TokenStreamExt as _;
use quote::quote;

/// Generation of Rust struct.
#[derive(Debug)]
pub struct StructDef<'a> {
    pub name: TypeName<'a>,
    base: Option<QualifiedName<'a>>,
    properties: Properties<'a>,
    parameters: Vec<Parameter<'a>>,
    actions: ActionsMap<'a>,
    odata: OData<'a>,
}

impl<'a> StructDef<'a> {
    /// # Errors
    ///
    /// Returns error if struct definition cannot be generated by the
    /// provided parameters.
    pub fn new(
        name: TypeName<'a>,
        base: Option<QualifiedName<'a>>,
        properties: Properties<'a>,
        parameters: Vec<Parameter<'a>>,
        odata: OData<'a>,
        actions: ActionsMap<'a>,
        config: &Config,
    ) -> Result<Self, Error<'a>> {
        if base.is_some() {
            let base_pname = StructFieldName::new_property(&config.base_type_prop_name);
            for p in &properties.properties {
                let pname = StructFieldName::new_property(p.name);
                if base_pname == pname {
                    return Err(Error::BaseTypeConflict);
                }
            }
            for p in &properties.nav_properties {
                let pname = StructFieldName::new_property(p.name);
                if base_pname == pname {
                    return Err(Error::BaseTypeConflict);
                }
            }
        }
        Ok(Self {
            name,
            base,
            properties,
            parameters,
            actions,
            odata,
        })
    }

    /// Generate rust code for the structure.
    pub fn generate(self, tokens: &mut TokenStream, config: &Config) {
        self.generate_read(tokens, config);
    }

    /// Generate rust code for the structure.
    pub fn generate_read(&self, tokens: &mut TokenStream, config: &Config) {
        enum ImplOdataType {
            Root,
            Child,
            None,
        }

        let top = &config.top_module_alias;
        let mut content = TokenStream::new();
        let odata_id = Ident::new("odata_id", Span::call_site());
        let impl_odata_type = if let Some(base) = self.base {
            let base_pname = StructFieldName::new_property(&config.base_type_prop_name);
            let typename = FullTypeName::new(base, config);
            content.extend(quote! {
                /// Base type
                #[serde(flatten)]
                pub #base_pname: #typename,
            });
            if *self.odata.must_have_id.inner() {
                ImplOdataType::Child
            } else {
                ImplOdataType::None
            }
        } else if *self.odata.must_have_id.inner() {
            // MustHaveId only for the root elements in type
            // hierarchy. This requirements by code
            // generation. Generator needs to add @odata.id field to
            // the struct. If we will add odata.id on each level it ma
            // break deserialization.
            content.extend(quote! {
                #[serde(rename="@odata.id")]
                pub #odata_id: ODataId,
            });
            ImplOdataType::Root
        } else {
            ImplOdataType::None
        };

        for p in &self.properties.properties {
            if p.odata.permissions_is_write_only() {
                continue;
            }
            Self::generate_property(&mut content, p, config);
        }

        for p in &self.properties.nav_properties {
            if p.odata.permissions_is_write_only() {
                continue;
            }
            Self::generate_nav_property(&mut content, p, config);
        }

        for a in self.actions.values() {
            Self::generate_action_property(&mut content, a, config);
        }

        for p in &self.parameters {
            Self::generate_parameter(&mut content, p, config);
        }

        let name = self.name;
        tokens.extend(doc_format_and_generate(self.name, &self.odata));

        #[allow(clippy::branches_sharing_code)]
        if self.can_serde_same_struct() {
            // If we can serialize and deserialize the same struct
            // then we derive Serialize / Deserialize and generate
            // allias type. TODO:
            tokens.extend(quote! {
                #[derive(Deserialize, Debug)]
                pub struct #name
            });
        } else {
            tokens.extend(quote! {
                #[derive(Deserialize, Debug)]
                pub struct #name
            });
        }

        tokens.append(TokenTree::Group(Group::new(Delimiter::Brace, content)));

        match impl_odata_type {
            ImplOdataType::Root => {
                tokens.extend(quote! {
                    impl #top::EntityType for #name {
                        #[inline]
                        fn id(&self) -> &ODataId {
                            &self.#odata_id
                        }
                    }
                    impl #top::Expandable for #name {}
                });
            }
            ImplOdataType::Child => {
                let top = &config.top_module_alias;
                tokens.extend(quote! {
                    impl #top::EntityType for #name {
                        #[inline]
                        fn id(&self) -> &ODataId {
                            self.base.id()
                        }
                    }
                    impl #top::Expandable for #name {}
                });
            }
            ImplOdataType::None => (),
        }
    }

    fn generate_property(content: &mut TokenStream, p: &Property<'_>, config: &Config) {
        content.extend(doc_format_and_generate(p.name, &p.odata));
        match p.ptype {
            PropertyType::One(v) => {
                let rename = Literal::string(p.name.inner().inner());
                let name = StructFieldName::new_property(p.name);
                let ptype = FullTypeName::new(v, config);
                content.extend(quote! { #[serde(rename=#rename)] });
                if p.redfish.is_required.into_inner() {
                    content.extend(quote! { pub #name: #ptype,  });
                } else {
                    content.extend(quote! { pub #name: Option<#ptype>, });
                }
            }
            PropertyType::CollectionOf(v) => {
                let rename = Literal::string(p.name.inner().inner());
                let name = StructFieldName::new_property(p.name);
                let ptype = FullTypeName::new(v, config);
                if p.redfish.is_required.into_inner() {
                    content.extend(quote! { #[serde(rename=#rename)] });
                } else {
                    content.extend(quote! { #[serde(rename=#rename, default)] });
                }
                content.extend(quote! { pub #name: Vec<#ptype>, });
            }
        }
    }

    fn generate_nav_property(content: &mut TokenStream, p: &NavProperty<'_>, config: &Config) {
        content.extend(doc_format_and_generate(p.name, &p.odata));
        match p.ptype {
            PropertyType::One(v) => {
                let rename = Literal::string(p.name.inner().inner());
                let name = StructFieldName::new_property(p.name);
                let ptype = FullTypeName::new(v, config);
                content.extend(quote! { #[serde(rename=#rename)] });
                if p.redfish.is_required.into_inner() {
                    content.extend(quote! { pub #name: NavProperty<#ptype>, });
                } else {
                    content.extend(quote! { pub #name: Option<NavProperty<#ptype>>, });
                }
            }
            PropertyType::CollectionOf(v) => {
                let rename = Literal::string(p.name.inner().inner());
                let name = StructFieldName::new_property(p.name);
                let ptype = FullTypeName::new(v, config);
                if p.redfish.is_required.into_inner() {
                    content.extend(quote! { #[serde(rename=#rename)] });
                } else {
                    content.extend(quote! { #[serde(rename=#rename, default)] });
                }
                content.extend(quote! { pub #name: Vec<NavProperty<#ptype>>, });
            }
        }
    }

    fn generate_parameter(content: &mut TokenStream, p: &Parameter<'_>, config: &Config) {
        content.extend(doc_format_and_generate(p.name, &p.odata));
        match p.ptype {
            ParameterType::Type(PropertyType::One(v)) => {
                let rename = Literal::string(p.name.inner().inner());
                let name = StructFieldName::new_parameter(p.name);
                let ptype = FullTypeName::new(v, config);
                content.extend(quote! { #[serde(rename=#rename)] });
                content.extend(quote! { pub #name: Option<#ptype>, });
            }
            ParameterType::Type(PropertyType::CollectionOf(v)) => {
                let rename = Literal::string(p.name.inner().inner());
                let name = StructFieldName::new_parameter(p.name);
                let ptype = FullTypeName::new(v, config);
                content.extend(quote! { #[serde(rename=#rename, default)] });
                content.extend(quote! { pub #name: Vec<#ptype>, });
            }
            ParameterType::Entity(PropertyType::One(_)) => {
                let top = &config.top_module_alias;
                let rename = Literal::string(p.name.inner().inner());
                let name = StructFieldName::new_parameter(p.name);
                content.extend(quote! { #[serde(rename=#rename)] });
                content.extend(quote! { pub #name: Option<#top::Reference>, });
            }
            ParameterType::Entity(PropertyType::CollectionOf(_)) => {
                let top = &config.top_module_alias;
                let rename = Literal::string(p.name.inner().inner());
                let name = StructFieldName::new_parameter(p.name);
                content.extend(quote! { #[serde(rename=#rename, default)] });
                content.extend(quote! { pub #name: Vec<#top::Reference>, });
            }
        }
    }

    fn generate_action_property(content: &mut TokenStream, a: &Action, config: &Config) {
        let top = &config.top_module_alias;
        let rename = Literal::string(&format!("#{}.{}", a.binding_name, a.name));
        let name = ActionName::new(a.name);
        let typename = TypeName::new_action(a.binding_name, a.name);
        content.extend(quote! { #[serde(rename=#rename)] });
        content.extend(quote! { pub #name: #top::Action<#typename>, });
    }

    fn can_serde_same_struct(&self) -> bool {
        self.base.is_none()
            && self.actions.is_empty()
            && self.parameters.is_empty()
            && self.properties.nav_properties.is_empty()
            && self.properties.properties.iter().all(|p| {
                p.odata
                    .permissions
                    .is_none_or(|p| p == Permissions::ReadWrite)
            })
    }
}
